/* eslint-disable */
/// <reference path="./custom.d.ts" />
// tslint:disable
// @ts-nocheck
/**
 * ExtranetAPI
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url'
import * as isomorphicFetch from 'isomorphic-fetch'
import {Configuration} from './configuration'

const BASE_PATH = '/'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
	csv: ',',
	ssv: ' ',
	tsv: '\t',
	pipes: '|',
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
	(url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
	url: string;
	options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
	protected configuration: Configuration

	constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
		if (configuration) {
			this.configuration = configuration
			this.basePath = configuration.basePath || this.basePath
		}
	}
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
	name: 'RequiredError'

	constructor(public field: string, msg?: string) {
		super(msg)
	}
}

/**
 *
 * @export
 * @interface AccountDto
 */
export interface AccountDto {
	/**
	 *
	 * @type {string}
	 * @memberof AccountDto
	 */
	login?: string;
	/**
	 *
	 * @type {string}
	 * @memberof AccountDto
	 */
	password?: string;
}

/**
 *
 * @export
 * @interface BuisnessCost
 */
export interface BuisnessCost {
	/**
	 *
	 * @type {number}
	 * @memberof BuisnessCost
	 */
	id?: number;
	/**
	 *
	 * @type {string}
	 * @memberof BuisnessCost
	 */
	name?: string;
	/**
	 *
	 * @type {number}
	 * @memberof BuisnessCost
	 */
	amount?: number;
	/**
	 *
	 * @type {Date}
	 * @memberof BuisnessCost
	 */
	date?: Date;
}

/**
 *
 * @export
 * @interface ClientDto
 */
export interface ClientDto {
	/**
	 *
	 * @type {number}
	 * @memberof ClientDto
	 */
	id?: number;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	communicationChannel?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	phoneNumber?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	mail?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	description?: string;
}

/**
 *
 * @export
 * @interface ClientPayment
 */
export interface ClientPayment {
	/**
	 *
	 * @type {Date}
	 * @memberof ClientPayment
	 */
	paymentDate?: Date;
	/**
	 *
	 * @type {number}
	 * @memberof ClientPayment
	 */
	amount?: number;
}

/**
 *
 * @export
 * @interface Cost
 */
export interface Cost {
	/**
	 *
	 * @type {number}
	 * @memberof Cost
	 */
	id?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Cost
	 */
	name?: string;
}

/**
 *
 * @export
 * @interface CostPayment
 */
export interface CostPayment {
	/**
	 *
	 * @type {number}
	 * @memberof CostPayment
	 */
	costId?: number;
	/**
	 *
	 * @type {Date}
	 * @memberof CostPayment
	 */
	paymentDate?: Date;
	/**
	 *
	 * @type {number}
	 * @memberof CostPayment
	 */
	amount?: number;
}

/**
 *
 * @export
 * @interface OutdatedProjectDto
 */
export interface OutdatedProjectDto {
	/**
	 *
	 * @type {Date}
	 * @memberof OutdatedProjectDto
	 */
	startDate?: Date;
	/**
	 *
	 * @type {Date}
	 * @memberof OutdatedProjectDto
	 */
	deadLine?: Date;
	/**
	 *
	 * @type {string}
	 * @memberof OutdatedProjectDto
	 */
	projectName?: string;
	/**
	 *
	 * @type {number}
	 * @memberof OutdatedProjectDto
	 */
	wastedDays?: number;
}

/**
 *
 * @export
 * @interface OutdatedProjectsDto
 */
export interface OutdatedProjectsDto {
	/**
	 *
	 * @type {Array<OutdatedProjectDto>}
	 * @memberof OutdatedProjectsDto
	 */
	outdatedProjects?: Array<OutdatedProjectDto>;
	/**
	 *
	 * @type {Period}
	 * @memberof OutdatedProjectsDto
	 */
	period?: Period;
	/**
	 *
	 * @type {number}
	 * @memberof OutdatedProjectsDto
	 */
	averageAmount?: number;
}

/**
 *
 * @export
 * @interface Period
 */
export interface Period {
	/**
	 *
	 * @type {Date}
	 * @memberof Period
	 */
	startDate?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof Period
	 */
	endDate?: string;
}

/**
 *
 * @export
 * @interface ProjectBudgetDto
 */
export interface ProjectBudgetDto {
	/**
	 *
	 * @type {number}
	 * @memberof ProjectBudgetDto
	 */
	id?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectBudgetDto
	 */
	projectId?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectBudgetDto
	 */
	projectCost?: number;
	/**
	 *
	 * @type {Array<ClientPayment>}
	 * @memberof ProjectBudgetDto
	 */
	clientPayments?: Array<ClientPayment>;
	/**
	 *
	 * @type {Array<CostPayment>}
	 * @memberof ProjectBudgetDto
	 */
	costPayments?: Array<CostPayment>;
}

/**
 *
 * @export
 * @interface ProjectDeadlineSettings
 */
export interface ProjectDeadlineSettings {
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDeadlineSettings
	 */
	id?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDeadlineSettings
	 */
	daysForDeadlineYellow?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDeadlineSettings
	 */
	daysForDeadlineRed?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDeadlineSettings
	 */
	defaultProjectDurationDays?: number;
}

/**
 *
 * @export
 * @interface ProjectDto
 */
export interface ProjectDto {
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDto
	 */
	id?: number;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectDto
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectDto
	 */
	contractNumber?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectDto
	 */
	dateOfStart?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectDto
	 */
	deadLine?: string;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDto
	 */
	clientId?: number;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectDto
	 */
	description?: string;
}

/**
 *
 * @export
 * @interface ProjectMarginDto
 */
export interface ProjectMarginDto {
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectMarginDto
	 */
	projectStartdate?: Date;
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectMarginDto
	 */
	projectDeadLine?: Date;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectMarginDto
	 */
	projectName?: string;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectMarginDto
	 */
	projectMargin?: number;
}

/**
 *
 * @export
 * @interface ProjectPriceDto
 */
export interface ProjectPriceDto {
	/**
	 *
	 * @type {string}
	 * @memberof ProjectPriceDto
	 */
	projectName?: string;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectPriceDto
	 */
	projectPrice?: number;
}

/**
 *
 * @export
 * @interface ProjectStage
 */
export interface ProjectStage {
	/**
	 *
	 * @type {number}
	 * @memberof ProjectStage
	 */
	id?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectStage
	 */
	projectId?: number;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectStage
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectStage
	 */
	description?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectStage
	 */
	completedOn?: Date;
	/**
	 *
	 * @type {boolean}
	 * @memberof ProjectStage
	 */
	isCompleted?: boolean;
}

/**
 *
 * @export
 * @interface ProjectsMagrinDto
 */
export interface ProjectsMagrinDto {
	/**
	 *
	 * @type {Array<ProjectMarginDto>}
	 * @memberof ProjectsMagrinDto
	 */
	projectMargins?: Array<ProjectMarginDto>;
	/**
	 *
	 * @type {Period}
	 * @memberof ProjectsMagrinDto
	 */
	period?: Period;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectsMagrinDto
	 */
	totalMargin?: number;
}

/**
 *
 * @export
 * @interface ProjectsPricesDto
 */
export interface ProjectsPricesDto {
	/**
	 *
	 * @type {number}
	 * @memberof ProjectsPricesDto
	 */
	averagePrice?: number;
	/**
	 *
	 * @type {Array<ProjectPriceDto>}
	 * @memberof ProjectsPricesDto
	 */
	projectPrices?: Array<ProjectPriceDto>;
	/**
	 *
	 * @type {ProjectPriceDto}
	 * @memberof ProjectsPricesDto
	 */
	maxProjectPrice?: ProjectPriceDto;
	/**
	 *
	 * @type {ProjectPriceDto}
	 * @memberof ProjectsPricesDto
	 */
	minProjectPrice?: ProjectPriceDto;
}

/**
 *
 * @export
 * @interface SearchAnalyticDto
 */
export interface SearchAnalyticDto {
	/**
	 *
	 * @type {string}
	 * @memberof SearchAnalyticDto
	 */
	name?: string;
	/**
	 *
	 * @type {Period}
	 * @memberof SearchAnalyticDto
	 */
	period?: Period;
}

/**
 *
 * @export
 * @interface SpendingOnCostDto
 */
export interface SpendingOnCostDto {
	/**
	 *
	 * @type {string}
	 * @memberof SpendingOnCostDto
	 */
	name?: string;
	/**
	 *
	 * @type {number}
	 * @memberof SpendingOnCostDto
	 */
	amount?: number;
}

/**
 *
 * @export
 * @interface SpendingOnProjectCostsDto
 */
export interface SpendingOnProjectCostsDto {
	/**
	 *
	 * @type {Array<SpendingOnCostDto>}
	 * @memberof SpendingOnProjectCostsDto
	 */
	spendingOnCosts?: Array<SpendingOnCostDto>;
	/**
	 *
	 * @type {string}
	 * @memberof SpendingOnProjectCostsDto
	 */
	projectName?: string;
}

/**
 *
 * @export
 * @interface UserDto
 */
export interface UserDto {
	/**
	 *
	 * @type {number}
	 * @memberof UserDto
	 */
	id?: number;
	/**
	 *
	 * @type {string}
	 * @memberof UserDto
	 */
	email?: string;
	/**
	 *
	 * @type {string}
	 * @memberof UserDto
	 */
	fullName?: string;
	/**
	 *
	 * @type {string}
	 * @memberof UserDto
	 */
	password?: string;
	/**
	 *
	 * @type {number}
	 * @memberof UserDto
	 */
	role?: number;
}

/**
 * AnalyticsApi - fetch parameter creator
 * @export
 */
export const AnalyticsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Маржа по проектам за период
		 * @param {SearchAnalyticDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsMarginPost(body?: SearchAnalyticDto, options: any = {}): FetchArgs {
			const localVarPath = `/analytics/margin`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'SearchAnalyticDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Маржа по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsMarginProjectIdGet(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling analyticsMarginProjectIdGet.')
			}
			const localVarPath = `/analytics/margin/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Просроченные проекты
		 * @param {SearchAnalyticDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsOutDatedProjectsPost(body?: SearchAnalyticDto, options: any = {}): FetchArgs {
			const localVarPath = `/analytics/outDatedProjects`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'SearchAnalyticDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Норма прибыли
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsProfitNormProjectIdGet(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling analyticsProfitNormProjectIdGet.')
			}
			const localVarPath = `/analytics/profitNorm/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Цены проектов
		 * @param {Period} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsProjectsPricesPost(body?: Period, options: any = {}): FetchArgs {
			const localVarPath = `/analytics/projectsPrices`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'Period' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Норма прибавочной стоимости
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsRateOfSurplusValueProjectIdGet(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling analyticsRateOfSurplusValueProjectIdGet.')
			}
			const localVarPath = `/analytics/rateOfSurplusValue/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Траты на издержки
		 * @param {SearchAnalyticDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsSpendingOnCostsPost(body?: SearchAnalyticDto, options: any = {}): FetchArgs {
			const localVarPath = `/analytics/spendingOnCosts`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'SearchAnalyticDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Траты на издержки по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsSpendingOnCostsProjectIdGet(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling analyticsSpendingOnCostsProjectIdGet.')
			}
			const localVarPath = `/analytics/spendingOnCosts/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Маржа по проектам за период
		 * @param {SearchAnalyticDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsMarginPost(body?: SearchAnalyticDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectsMagrinDto> {
			const localVarFetchArgs = AnalyticsApiFetchParamCreator(configuration).analyticsMarginPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Маржа по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsMarginProjectIdGet(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = AnalyticsApiFetchParamCreator(configuration).analyticsMarginProjectIdGet(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Просроченные проекты
		 * @param {SearchAnalyticDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsOutDatedProjectsPost(body?: SearchAnalyticDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutdatedProjectsDto> {
			const localVarFetchArgs = AnalyticsApiFetchParamCreator(configuration).analyticsOutDatedProjectsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Норма прибыли
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsProfitNormProjectIdGet(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
			const localVarFetchArgs = AnalyticsApiFetchParamCreator(configuration).analyticsProfitNormProjectIdGet(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Цены проектов
		 * @param {Period} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsProjectsPricesPost(body?: Period, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectsPricesDto> {
			const localVarFetchArgs = AnalyticsApiFetchParamCreator(configuration).analyticsProjectsPricesPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Норма прибавочной стоимости
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsRateOfSurplusValueProjectIdGet(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
			const localVarFetchArgs = AnalyticsApiFetchParamCreator(configuration).analyticsRateOfSurplusValueProjectIdGet(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Траты на издержки
		 * @param {SearchAnalyticDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsSpendingOnCostsPost(body?: SearchAnalyticDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpendingOnCostDto>> {
			const localVarFetchArgs = AnalyticsApiFetchParamCreator(configuration).analyticsSpendingOnCostsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Траты на издержки по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsSpendingOnCostsProjectIdGet(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpendingOnProjectCostsDto> {
			const localVarFetchArgs = AnalyticsApiFetchParamCreator(configuration).analyticsSpendingOnCostsProjectIdGet(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Маржа по проектам за период
		 * @param {SearchAnalyticDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsMarginPost(body?: SearchAnalyticDto, options?: any) {
			return AnalyticsApiFp(configuration).analyticsMarginPost(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Маржа по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsMarginProjectIdGet(projectId: number, options?: any) {
			return AnalyticsApiFp(configuration).analyticsMarginProjectIdGet(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Просроченные проекты
		 * @param {SearchAnalyticDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsOutDatedProjectsPost(body?: SearchAnalyticDto, options?: any) {
			return AnalyticsApiFp(configuration).analyticsOutDatedProjectsPost(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Норма прибыли
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsProfitNormProjectIdGet(projectId: number, options?: any) {
			return AnalyticsApiFp(configuration).analyticsProfitNormProjectIdGet(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Цены проектов
		 * @param {Period} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsProjectsPricesPost(body?: Period, options?: any) {
			return AnalyticsApiFp(configuration).analyticsProjectsPricesPost(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Норма прибавочной стоимости
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsRateOfSurplusValueProjectIdGet(projectId: number, options?: any) {
			return AnalyticsApiFp(configuration).analyticsRateOfSurplusValueProjectIdGet(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Траты на издержки
		 * @param {SearchAnalyticDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsSpendingOnCostsPost(body?: SearchAnalyticDto, options?: any) {
			return AnalyticsApiFp(configuration).analyticsSpendingOnCostsPost(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Траты на издержки по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsSpendingOnCostsProjectIdGet(projectId: number, options?: any) {
			return AnalyticsApiFp(configuration).analyticsSpendingOnCostsProjectIdGet(projectId, options)(fetch, basePath)
		},
	}
}

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
	/**
	 *
	 * @summary Маржа по проектам за период
	 * @param {SearchAnalyticDto} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AnalyticsApi
	 */
	public analyticsMarginPost(body?: SearchAnalyticDto, options?: any) {
		return AnalyticsApiFp(this.configuration).analyticsMarginPost(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Маржа по проекту
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AnalyticsApi
	 */
	public analyticsMarginProjectIdGet(projectId: number, options?: any) {
		return AnalyticsApiFp(this.configuration).analyticsMarginProjectIdGet(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Просроченные проекты
	 * @param {SearchAnalyticDto} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AnalyticsApi
	 */
	public analyticsOutDatedProjectsPost(body?: SearchAnalyticDto, options?: any) {
		return AnalyticsApiFp(this.configuration).analyticsOutDatedProjectsPost(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Норма прибыли
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AnalyticsApi
	 */
	public analyticsProfitNormProjectIdGet(projectId: number, options?: any) {
		return AnalyticsApiFp(this.configuration).analyticsProfitNormProjectIdGet(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Цены проектов
	 * @param {Period} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AnalyticsApi
	 */
	public analyticsProjectsPricesPost(body?: Period, options?: any) {
		return AnalyticsApiFp(this.configuration).analyticsProjectsPricesPost(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Норма прибавочной стоимости
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AnalyticsApi
	 */
	public analyticsRateOfSurplusValueProjectIdGet(projectId: number, options?: any) {
		return AnalyticsApiFp(this.configuration).analyticsRateOfSurplusValueProjectIdGet(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Траты на издержки
	 * @param {SearchAnalyticDto} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AnalyticsApi
	 */
	public analyticsSpendingOnCostsPost(body?: SearchAnalyticDto, options?: any) {
		return AnalyticsApiFp(this.configuration).analyticsSpendingOnCostsPost(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Траты на издержки по проекту
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AnalyticsApi
	 */
	public analyticsSpendingOnCostsProjectIdGet(projectId: number, options?: any) {
		return AnalyticsApiFp(this.configuration).analyticsSpendingOnCostsProjectIdGet(projectId, options)(this.fetch, this.basePath)
	}

}

/**
 * AuthentificationApi - fetch parameter creator
 * @export
 */
export const AuthentificationApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Логинация пользователя
		 * @param {AccountDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authentificationPost(body?: AccountDto, options: any = {}): FetchArgs {
			const localVarPath = `/authentification`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'AccountDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Выход пользователя
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		logoutPost(options: any = {}): FetchArgs {
			const localVarPath = `/logout`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * AuthentificationApi - functional programming interface
 * @export
 */
export const AuthentificationApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Логинация пользователя
		 * @param {AccountDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authentificationPost(body?: AccountDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = AuthentificationApiFetchParamCreator(configuration).authentificationPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Выход пользователя
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		logoutPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = AuthentificationApiFetchParamCreator(configuration).logoutPost(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * AuthentificationApi - factory interface
 * @export
 */
export const AuthentificationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Логинация пользователя
		 * @param {AccountDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authentificationPost(body?: AccountDto, options?: any) {
			return AuthentificationApiFp(configuration).authentificationPost(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Выход пользователя
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		logoutPost(options?: any) {
			return AuthentificationApiFp(configuration).logoutPost(options)(fetch, basePath)
		},
	}
}

/**
 * AuthentificationApi - object-oriented interface
 * @export
 * @class AuthentificationApi
 * @extends {BaseAPI}
 */
export class AuthentificationApi extends BaseAPI {
	/**
	 *
	 * @summary Логинация пользователя
	 * @param {AccountDto} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthentificationApi
	 */
	public authentificationPost(body?: AccountDto, options?: any) {
		return AuthentificationApiFp(this.configuration).authentificationPost(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Выход пользователя
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthentificationApi
	 */
	public logoutPost(options?: any) {
		return AuthentificationApiFp(this.configuration).logoutPost(options)(this.fetch, this.basePath)
	}

}

/**
 * BuisnessCostApi - fetch parameter creator
 * @export
 */
export const BuisnessCostApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить все бизнесовые издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsGet(options: any = {}): FetchArgs {
			const localVarPath = `/buisness-costs`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Удалить бизнесовую издержку
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsIdDelete(id: number, options: any = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling buisnessCostsIdDelete.')
			}
			const localVarPath = `/buisness-costs/{id}`
				.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'DELETE'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Создать бизнесовую издержку
		 * @param {BuisnessCost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsPost(body: BuisnessCost, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling buisnessCostsPost.')
			}
			const localVarPath = `/buisness-costs`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'BuisnessCost' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * BuisnessCostApi - functional programming interface
 * @export
 */
export const BuisnessCostApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить все бизнесовые издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BuisnessCost>> {
			const localVarFetchArgs = BuisnessCostApiFetchParamCreator(configuration).buisnessCostsGet(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Удалить бизнесовую издержку
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = BuisnessCostApiFetchParamCreator(configuration).buisnessCostsIdDelete(id, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Создать бизнесовую издержку
		 * @param {BuisnessCost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsPost(body: BuisnessCost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = BuisnessCostApiFetchParamCreator(configuration).buisnessCostsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * BuisnessCostApi - factory interface
 * @export
 */
export const BuisnessCostApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить все бизнесовые издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsGet(options?: any) {
			return BuisnessCostApiFp(configuration).buisnessCostsGet(options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Удалить бизнесовую издержку
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsIdDelete(id: number, options?: any) {
			return BuisnessCostApiFp(configuration).buisnessCostsIdDelete(id, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Создать бизнесовую издержку
		 * @param {BuisnessCost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsPost(body: BuisnessCost, options?: any) {
			return BuisnessCostApiFp(configuration).buisnessCostsPost(body, options)(fetch, basePath)
		},
	}
}

/**
 * BuisnessCostApi - object-oriented interface
 * @export
 * @class BuisnessCostApi
 * @extends {BaseAPI}
 */
export class BuisnessCostApi extends BaseAPI {
	/**
	 *
	 * @summary Получить все бизнесовые издержки
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BuisnessCostApi
	 */
	public buisnessCostsGet(options?: any) {
		return BuisnessCostApiFp(this.configuration).buisnessCostsGet(options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Удалить бизнесовую издержку
	 * @param {number} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BuisnessCostApi
	 */
	public buisnessCostsIdDelete(id: number, options?: any) {
		return BuisnessCostApiFp(this.configuration).buisnessCostsIdDelete(id, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Создать бизнесовую издержку
	 * @param {BuisnessCost} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BuisnessCostApi
	 */
	public buisnessCostsPost(body: BuisnessCost, options?: any) {
		return BuisnessCostApiFp(this.configuration).buisnessCostsPost(body, options)(this.fetch, this.basePath)
	}

}

/**
 * ClientApi - fetch parameter creator
 * @export
 */
export const ClientApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Обновить основную информацию по клиенту
		 * @param {ClientDto} body
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdClientUpdatingPost(body: ClientDto, clientId: number, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling clientsClientIdClientUpdatingPost.')
			}
			// verify required parameter 'clientId' is not null or undefined
			if (clientId === null || clientId === undefined) {
				throw new RequiredError('clientId', 'Required parameter clientId was null or undefined when calling clientsClientIdClientUpdatingPost.')
			}
			const localVarPath = `/clients/{clientId}/client-updating`
				.replace(`{${'clientId'}}`, encodeURIComponent(String(clientId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ClientDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Удалить клиента
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdDelete(clientId: number, options: any = {}): FetchArgs {
			// verify required parameter 'clientId' is not null or undefined
			if (clientId === null || clientId === undefined) {
				throw new RequiredError('clientId', 'Required parameter clientId was null or undefined when calling clientsClientIdDelete.')
			}
			const localVarPath = `/clients/{clientId}`
				.replace(`{${'clientId'}}`, encodeURIComponent(String(clientId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'DELETE'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить клиента по идентификатору
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdGet(clientId: number, options: any = {}): FetchArgs {
			// verify required parameter 'clientId' is not null or undefined
			if (clientId === null || clientId === undefined) {
				throw new RequiredError('clientId', 'Required parameter clientId was null or undefined when calling clientsClientIdGet.')
			}
			const localVarPath = `/clients/{clientId}`
				.replace(`{${'clientId'}}`, encodeURIComponent(String(clientId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить всех клиентов
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsGet(options: any = {}): FetchArgs {
			const localVarPath = `/clients`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Создать клиента
		 * @param {ClientDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsPost(body: ClientDto, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling clientsPost.')
			}
			const localVarPath = `/clients`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ClientDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Обновить основную информацию по клиенту
		 * @param {ClientDto} body
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdClientUpdatingPost(body: ClientDto, clientId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsClientIdClientUpdatingPost(body, clientId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Удалить клиента
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdDelete(clientId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsClientIdDelete(clientId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить клиента по идентификатору
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdGet(clientId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClientDto> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsClientIdGet(clientId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить всех клиентов
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ClientDto>> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsGet(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Создать клиента
		 * @param {ClientDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsPost(body: ClientDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Обновить основную информацию по клиенту
		 * @param {ClientDto} body
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdClientUpdatingPost(body: ClientDto, clientId: number, options?: any) {
			return ClientApiFp(configuration).clientsClientIdClientUpdatingPost(body, clientId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Удалить клиента
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdDelete(clientId: number, options?: any) {
			return ClientApiFp(configuration).clientsClientIdDelete(clientId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить клиента по идентификатору
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdGet(clientId: number, options?: any) {
			return ClientApiFp(configuration).clientsClientIdGet(clientId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить всех клиентов
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsGet(options?: any) {
			return ClientApiFp(configuration).clientsGet(options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Создать клиента
		 * @param {ClientDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsPost(body: ClientDto, options?: any) {
			return ClientApiFp(configuration).clientsPost(body, options)(fetch, basePath)
		},
	}
}

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
	/**
	 *
	 * @summary Обновить основную информацию по клиенту
	 * @param {ClientDto} body
	 * @param {number} clientId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsClientIdClientUpdatingPost(body: ClientDto, clientId: number, options?: any) {
		return ClientApiFp(this.configuration).clientsClientIdClientUpdatingPost(body, clientId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Удалить клиента
	 * @param {number} clientId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsClientIdDelete(clientId: number, options?: any) {
		return ClientApiFp(this.configuration).clientsClientIdDelete(clientId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить клиента по идентификатору
	 * @param {number} clientId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsClientIdGet(clientId: number, options?: any) {
		return ClientApiFp(this.configuration).clientsClientIdGet(clientId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить всех клиентов
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsGet(options?: any) {
		return ClientApiFp(this.configuration).clientsGet(options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Создать клиента
	 * @param {ClientDto} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsPost(body: ClientDto, options?: any) {
		return ClientApiFp(this.configuration).clientsPost(body, options)(this.fetch, this.basePath)
	}

}

/**
 * CostApi - fetch parameter creator
 * @export
 */
export const CostApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить издержку по идентификатору
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdGet(costId: number, options: any = {}): FetchArgs {
			// verify required parameter 'costId' is not null or undefined
			if (costId === null || costId === undefined) {
				throw new RequiredError('costId', 'Required parameter costId was null or undefined when calling costsCostIdGet.')
			}
			const localVarPath = `/costs/{costId}`
				.replace(`{${'costId'}}`, encodeURIComponent(String(costId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить все издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsGet(options: any = {}): FetchArgs {
			const localVarPath = `/costs`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Создать издержку
		 * @param {Cost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsPost(body: Cost, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling costsPost.')
			}
			const localVarPath = `/costs`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'Cost' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * CostApi - functional programming interface
 * @export
 */
export const CostApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить издержку по идентификатору
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdGet(costId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cost> {
			const localVarFetchArgs = CostApiFetchParamCreator(configuration).costsCostIdGet(costId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить все издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Cost>> {
			const localVarFetchArgs = CostApiFetchParamCreator(configuration).costsGet(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Создать издержку
		 * @param {Cost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsPost(body: Cost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = CostApiFetchParamCreator(configuration).costsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * CostApi - factory interface
 * @export
 */
export const CostApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить издержку по идентификатору
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdGet(costId: number, options?: any) {
			return CostApiFp(configuration).costsCostIdGet(costId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить все издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsGet(options?: any) {
			return CostApiFp(configuration).costsGet(options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Создать издержку
		 * @param {Cost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsPost(body: Cost, options?: any) {
			return CostApiFp(configuration).costsPost(body, options)(fetch, basePath)
		},
	}
}

/**
 * CostApi - object-oriented interface
 * @export
 * @class CostApi
 * @extends {BaseAPI}
 */
export class CostApi extends BaseAPI {
	/**
	 *
	 * @summary Получить издержку по идентификатору
	 * @param {number} costId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CostApi
	 */
	public costsCostIdGet(costId: number, options?: any) {
		return CostApiFp(this.configuration).costsCostIdGet(costId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить все издержки
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CostApi
	 */
	public costsGet(options?: any) {
		return CostApiFp(this.configuration).costsGet(options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Создать издержку
	 * @param {Cost} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CostApi
	 */
	public costsPost(body: Cost, options?: any) {
		return CostApiFp(this.configuration).costsPost(body, options)(this.fetch, this.basePath)
	}

}

/**
 * ProjectApi - fetch parameter creator
 * @export
 */
export const ProjectApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить все проекты
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsGet(options: any = {}): FetchArgs {
			const localVarPath = `/projects`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Создать проект
		 * @param {ProjectDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsPost(body: ProjectDto, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectsPost.')
			}
			const localVarPath = `/projects`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ProjectDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Завершить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdCompletePost(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdCompletePost.')
			}
			const localVarPath = `/projects/{projectId}/complete`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Удалить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdDelete(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdDelete.')
			}
			const localVarPath = `/projects/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'DELETE'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить проект по идентификатору
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdGet(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdGet.')
			}
			const localVarPath = `/projects/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Обновить основную информацию по проекту
		 * @param {ProjectDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdProjectUpdatingPost(body: ProjectDto, projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectsProjectIdProjectUpdatingPost.')
			}
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdProjectUpdatingPost.')
			}
			const localVarPath = `/projects/{projectId}/project-updating`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ProjectDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Возобновить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdRunPost(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdRunPost.')
			}
			const localVarPath = `/projects/{projectId}/run`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Остановить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdStopPost(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdStopPost.')
			}
			const localVarPath = `/projects/{projectId}/stop`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить все проекты
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectDto>> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsGet(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Создать проект
		 * @param {ProjectDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsPost(body: ProjectDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Завершить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdCompletePost(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdCompletePost(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Удалить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdDelete(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdDelete(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить проект по идентификатору
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdGet(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectDto> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdGet(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Обновить основную информацию по проекту
		 * @param {ProjectDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdProjectUpdatingPost(body: ProjectDto, projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdProjectUpdatingPost(body, projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Возобновить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdRunPost(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdRunPost(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Остановить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdStopPost(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdStopPost(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить все проекты
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsGet(options?: any) {
			return ProjectApiFp(configuration).projectsGet(options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Создать проект
		 * @param {ProjectDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsPost(body: ProjectDto, options?: any) {
			return ProjectApiFp(configuration).projectsPost(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Завершить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdCompletePost(projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdCompletePost(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Удалить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdDelete(projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdDelete(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить проект по идентификатору
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdGet(projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdGet(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Обновить основную информацию по проекту
		 * @param {ProjectDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdProjectUpdatingPost(body: ProjectDto, projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdProjectUpdatingPost(body, projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Возобновить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdRunPost(projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdRunPost(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Остановить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdStopPost(projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdStopPost(projectId, options)(fetch, basePath)
		},
	}
}

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
	/**
	 *
	 * @summary Получить все проекты
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsGet(options?: any) {
		return ProjectApiFp(this.configuration).projectsGet(options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Создать проект
	 * @param {ProjectDto} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsPost(body: ProjectDto, options?: any) {
		return ProjectApiFp(this.configuration).projectsPost(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Завершить проект
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdCompletePost(projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdCompletePost(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Удалить проект
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdDelete(projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdDelete(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить проект по идентификатору
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdGet(projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdGet(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Обновить основную информацию по проекту
	 * @param {ProjectDto} body
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdProjectUpdatingPost(body: ProjectDto, projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdProjectUpdatingPost(body, projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Возобновить проект
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdRunPost(projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdRunPost(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Остановить проект
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdStopPost(projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdStopPost(projectId, options)(this.fetch, this.basePath)
	}

}

/**
 * ProjectBudgetApi - fetch parameter creator
 * @export
 */
export const ProjectBudgetApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить бюджет по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdGet(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectBudgetsProjectIdGet.')
			}
			const localVarPath = `/project-budgets/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Обновить бюджет проекта
		 * @param {ProjectBudgetDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdProjectBudgetUpdatingPost(body: ProjectBudgetDto, projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectBudgetsProjectIdProjectBudgetUpdatingPost.')
			}
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectBudgetsProjectIdProjectBudgetUpdatingPost.')
			}
			const localVarPath = `/project-budgets/{projectId}/project-budget-updating`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ProjectBudgetDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ProjectBudgetApi - functional programming interface
 * @export
 */
export const ProjectBudgetApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить бюджет по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdGet(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectBudgetDto> {
			const localVarFetchArgs = ProjectBudgetApiFetchParamCreator(configuration).projectBudgetsProjectIdGet(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Обновить бюджет проекта
		 * @param {ProjectBudgetDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdProjectBudgetUpdatingPost(body: ProjectBudgetDto, projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectBudgetDto> {
			const localVarFetchArgs = ProjectBudgetApiFetchParamCreator(configuration).projectBudgetsProjectIdProjectBudgetUpdatingPost(body, projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * ProjectBudgetApi - factory interface
 * @export
 */
export const ProjectBudgetApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить бюджет по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdGet(projectId: number, options?: any) {
			return ProjectBudgetApiFp(configuration).projectBudgetsProjectIdGet(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Обновить бюджет проекта
		 * @param {ProjectBudgetDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdProjectBudgetUpdatingPost(body: ProjectBudgetDto, projectId: number, options?: any) {
			return ProjectBudgetApiFp(configuration).projectBudgetsProjectIdProjectBudgetUpdatingPost(body, projectId, options)(fetch, basePath)
		},
	}
}

/**
 * ProjectBudgetApi - object-oriented interface
 * @export
 * @class ProjectBudgetApi
 * @extends {BaseAPI}
 */
export class ProjectBudgetApi extends BaseAPI {
	/**
	 *
	 * @summary Получить бюджет по проекту
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectBudgetApi
	 */
	public projectBudgetsProjectIdGet(projectId: number, options?: any) {
		return ProjectBudgetApiFp(this.configuration).projectBudgetsProjectIdGet(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Обновить бюджет проекта
	 * @param {ProjectBudgetDto} body
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectBudgetApi
	 */
	public projectBudgetsProjectIdProjectBudgetUpdatingPost(body: ProjectBudgetDto, projectId: number, options?: any) {
		return ProjectBudgetApiFp(this.configuration).projectBudgetsProjectIdProjectBudgetUpdatingPost(body, projectId, options)(this.fetch, this.basePath)
	}

}

/**
 * ProjectDeadlineApi - fetch parameter creator
 * @export
 */
export const ProjectDeadlineApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить текущий дедлайн
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectDeadlineSettingsGet(options: any = {}): FetchArgs {
			const localVarPath = `/project-deadline-settings`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Обновить информацию по дедлайну
		 * @param {ProjectDeadlineSettings} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body: ProjectDeadlineSettings, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost.')
			}
			const localVarPath = `/project-deadline-settings/project-deadline-settings-updating`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ProjectDeadlineSettings' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ProjectDeadlineApi - functional programming interface
 * @export
 */
export const ProjectDeadlineApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить текущий дедлайн
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectDeadlineSettingsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectDeadlineSettings> {
			const localVarFetchArgs = ProjectDeadlineApiFetchParamCreator(configuration).projectDeadlineSettingsGet(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Обновить информацию по дедлайну
		 * @param {ProjectDeadlineSettings} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body: ProjectDeadlineSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectDeadlineApiFetchParamCreator(configuration).projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * ProjectDeadlineApi - factory interface
 * @export
 */
export const ProjectDeadlineApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить текущий дедлайн
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectDeadlineSettingsGet(options?: any) {
			return ProjectDeadlineApiFp(configuration).projectDeadlineSettingsGet(options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Обновить информацию по дедлайну
		 * @param {ProjectDeadlineSettings} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body: ProjectDeadlineSettings, options?: any) {
			return ProjectDeadlineApiFp(configuration).projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body, options)(fetch, basePath)
		},
	}
}

/**
 * ProjectDeadlineApi - object-oriented interface
 * @export
 * @class ProjectDeadlineApi
 * @extends {BaseAPI}
 */
export class ProjectDeadlineApi extends BaseAPI {
	/**
	 *
	 * @summary Получить текущий дедлайн
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectDeadlineApi
	 */
	public projectDeadlineSettingsGet(options?: any) {
		return ProjectDeadlineApiFp(this.configuration).projectDeadlineSettingsGet(options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Обновить информацию по дедлайну
	 * @param {ProjectDeadlineSettings} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectDeadlineApi
	 */
	public projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body: ProjectDeadlineSettings, options?: any) {
		return ProjectDeadlineApiFp(this.configuration).projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body, options)(this.fetch, this.basePath)
	}

}

/**
 * ProjectStageApi - fetch parameter creator
 * @export
 */
export const ProjectStageApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить этапы проекта
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectIdGet(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectStagesProjectIdGet.')
			}
			const localVarPath = `/project-stages/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Обновить основную информацию по этапу проекта
		 * @param {ProjectStage} body
		 * @param {number} projectStageId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectStageIdProjectStageUpdatingPost(body: ProjectStage, projectStageId: number, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectStagesProjectStageIdProjectStageUpdatingPost.')
			}
			// verify required parameter 'projectStageId' is not null or undefined
			if (projectStageId === null || projectStageId === undefined) {
				throw new RequiredError('projectStageId', 'Required parameter projectStageId was null or undefined when calling projectStagesProjectStageIdProjectStageUpdatingPost.')
			}
			const localVarPath = `/project-stages/{projectStageId}/project-stage-updating`
				.replace(`{${'projectStageId'}}`, encodeURIComponent(String(projectStageId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ProjectStage' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ProjectStageApi - functional programming interface
 * @export
 */
export const ProjectStageApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить этапы проекта
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectIdGet(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectStage>> {
			const localVarFetchArgs = ProjectStageApiFetchParamCreator(configuration).projectStagesProjectIdGet(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Обновить основную информацию по этапу проекта
		 * @param {ProjectStage} body
		 * @param {number} projectStageId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectStageIdProjectStageUpdatingPost(body: ProjectStage, projectStageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectStageApiFetchParamCreator(configuration).projectStagesProjectStageIdProjectStageUpdatingPost(body, projectStageId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * ProjectStageApi - factory interface
 * @export
 */
export const ProjectStageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить этапы проекта
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectIdGet(projectId: number, options?: any) {
			return ProjectStageApiFp(configuration).projectStagesProjectIdGet(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Обновить основную информацию по этапу проекта
		 * @param {ProjectStage} body
		 * @param {number} projectStageId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectStageIdProjectStageUpdatingPost(body: ProjectStage, projectStageId: number, options?: any) {
			return ProjectStageApiFp(configuration).projectStagesProjectStageIdProjectStageUpdatingPost(body, projectStageId, options)(fetch, basePath)
		},
	}
}

/**
 * ProjectStageApi - object-oriented interface
 * @export
 * @class ProjectStageApi
 * @extends {BaseAPI}
 */
export class ProjectStageApi extends BaseAPI {
	/**
	 *
	 * @summary Получить этапы проекта
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectStageApi
	 */
	public projectStagesProjectIdGet(projectId: number, options?: any) {
		return ProjectStageApiFp(this.configuration).projectStagesProjectIdGet(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Обновить основную информацию по этапу проекта
	 * @param {ProjectStage} body
	 * @param {number} projectStageId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectStageApi
	 */
	public projectStagesProjectStageIdProjectStageUpdatingPost(body: ProjectStage, projectStageId: number, options?: any) {
		return ProjectStageApiFp(this.configuration).projectStagesProjectStageIdProjectStageUpdatingPost(body, projectStageId, options)(this.fetch, this.basePath)
	}

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Удаление пользователя
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersIdDelete(id: number, options: any = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling usersIdDelete.')
			}
			const localVarPath = `/users/{id}`
				.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'DELETE'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получение пользователя
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersIdGet(id: number, options: any = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling usersIdGet.')
			}
			const localVarPath = `/users/{id}`
				.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Создание пользователя
		 * @param {UserDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPost(body?: UserDto, options: any = {}): FetchArgs {
			const localVarPath = `/users`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'UserDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Обновление пользователя
		 * @param {UserDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPut(body?: UserDto, options: any = {}): FetchArgs {
			const localVarPath = `/users`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'PUT'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'UserDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Поиск пользователей
		 * @param {string} [fullNameSearchPattern]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersSearchPost(fullNameSearchPattern?: string, options: any = {}): FetchArgs {
			const localVarPath = `/users/search`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (fullNameSearchPattern !== undefined) {
				localVarQueryParameter['fullNameSearchPattern'] = fullNameSearchPattern
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Удаление пользователя
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdDelete(id, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получение пользователя
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserDto> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdGet(id, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Создание пользователя
		 * @param {UserDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPost(body?: UserDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Обновление пользователя
		 * @param {UserDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPut(body?: UserDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersPut(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Поиск пользователей
		 * @param {string} [fullNameSearchPattern]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersSearchPost(fullNameSearchPattern?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserDto>> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersSearchPost(fullNameSearchPattern, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Удаление пользователя
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersIdDelete(id: number, options?: any) {
			return UserApiFp(configuration).usersIdDelete(id, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получение пользователя
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersIdGet(id: number, options?: any) {
			return UserApiFp(configuration).usersIdGet(id, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Создание пользователя
		 * @param {UserDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPost(body?: UserDto, options?: any) {
			return UserApiFp(configuration).usersPost(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Обновление пользователя
		 * @param {UserDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPut(body?: UserDto, options?: any) {
			return UserApiFp(configuration).usersPut(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Поиск пользователей
		 * @param {string} [fullNameSearchPattern]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersSearchPost(fullNameSearchPattern?: string, options?: any) {
			return UserApiFp(configuration).usersSearchPost(fullNameSearchPattern, options)(fetch, basePath)
		},
	}
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
	/**
	 *
	 * @summary Удаление пользователя
	 * @param {number} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public usersIdDelete(id: number, options?: any) {
		return UserApiFp(this.configuration).usersIdDelete(id, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получение пользователя
	 * @param {number} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public usersIdGet(id: number, options?: any) {
		return UserApiFp(this.configuration).usersIdGet(id, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Создание пользователя
	 * @param {UserDto} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public usersPost(body?: UserDto, options?: any) {
		return UserApiFp(this.configuration).usersPost(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Обновление пользователя
	 * @param {UserDto} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public usersPut(body?: UserDto, options?: any) {
		return UserApiFp(this.configuration).usersPut(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Поиск пользователей
	 * @param {string} [fullNameSearchPattern]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public usersSearchPost(fullNameSearchPattern?: string, options?: any) {
		return UserApiFp(this.configuration).usersSearchPost(fullNameSearchPattern, options)(this.fetch, this.basePath)
	}

}

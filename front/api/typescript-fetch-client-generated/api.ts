/* eslint-disable */
/// <reference path="./custom.d.ts" />
// tslint:disable
// @ts-nocheck
/**
 * ExtranetAPI
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url'
import * as isomorphicFetch from 'isomorphic-fetch'
import {Configuration} from './configuration'

const BASE_PATH = '/'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
	csv: ',',
	ssv: ' ',
	tsv: '\t',
	pipes: '|',
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
	(url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
	url: string;
	options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
	protected configuration: Configuration

	constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
		if (configuration) {
			this.configuration = configuration
			this.basePath = configuration.basePath || this.basePath
		}
	}
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
	name: 'RequiredError'

	constructor(public field: string, msg?: string) {
		super(msg)
	}
}

/**
 *
 * @export
 * @interface ClientDto
 */
export interface ClientDto {
	/**
	 *
	 * @type {number}
	 * @memberof ClientDto
	 */
	id?: number;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	communicationChannel?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	phoneNumber?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	mail?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	description?: string;
}

/**
 *
 * @export
 * @interface ClientPayment
 */
export interface ClientPayment {
	/**
	 *
	 * @type {Date}
	 * @memberof ClientPayment
	 */
	paymentDate?: Date;
	/**
	 *
	 * @type {number}
	 * @memberof ClientPayment
	 */
	amount?: number;
}

/**
 *
 * @export
 * @interface Cost
 */
export interface Cost {
	/**
	 *
	 * @type {number}
	 * @memberof Cost
	 */
	id?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Cost
	 */
	name?: string;
}

/**
 *
 * @export
 * @interface CostPayment
 */
export interface CostPayment {
	/**
	 *
	 * @type {number}
	 * @memberof CostPayment
	 */
	costId?: number;
	/**
	 *
	 * @type {Date}
	 * @memberof CostPayment
	 */
	paymentDate?: Date;
	/**
	 *
	 * @type {number}
	 * @memberof CostPayment
	 */
	amount?: number;
}

/**
 *
 * @export
 * @interface ProjectBudgetDto
 */
export interface ProjectBudgetDto {
	/**
	 *
	 * @type {number}
	 * @memberof ProjectBudgetDto
	 */
	id?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectBudgetDto
	 */
	projectId?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectBudgetDto
	 */
	projectCost?: number;
	/**
	 *
	 * @type {Array<ClientPayment>}
	 * @memberof ProjectBudgetDto
	 */
	clientPayments?: Array<ClientPayment>;
	/**
	 *
	 * @type {Array<CostPayment>}
	 * @memberof ProjectBudgetDto
	 */
	costPayments?: Array<CostPayment>;
}

/**
 *
 * @export
 * @interface ProjectDto
 */
export interface ProjectDto {
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDto
	 */
	id?: number;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectDto
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectDto
	 */
	contractNumber?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectDto
	 */
	dateOfStart?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectDto
	 */
	deadLine?: string;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDto
	 */
	clientId?: number;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectDto
	 */
	description?: string;
}

/**
 * ClientApi - fetch parameter creator
 * @export
 */
export const ClientApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Обновить основную информацию по клиенту
		 * @param {ClientDto} body
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdClientUpdatingPost(body: ClientDto, clientId: number, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling clientsClientIdClientUpdatingPost.')
			}
			// verify required parameter 'clientId' is not null or undefined
			if (clientId === null || clientId === undefined) {
				throw new RequiredError('clientId', 'Required parameter clientId was null or undefined when calling clientsClientIdClientUpdatingPost.')
			}
			const localVarPath = `/clients/{clientId}/client-updating`
				.replace(`{${'clientId'}}`, encodeURIComponent(String(clientId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ClientDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Удалить клиента
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdDelete(clientId: number, options: any = {}): FetchArgs {
			// verify required parameter 'clientId' is not null or undefined
			if (clientId === null || clientId === undefined) {
				throw new RequiredError('clientId', 'Required parameter clientId was null or undefined when calling clientsClientIdDelete.')
			}
			const localVarPath = `/clients/{clientId}`
				.replace(`{${'clientId'}}`, encodeURIComponent(String(clientId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'DELETE'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить клиента по идентификатору
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdGet(clientId: number, options: any = {}): FetchArgs {
			// verify required parameter 'clientId' is not null or undefined
			if (clientId === null || clientId === undefined) {
				throw new RequiredError('clientId', 'Required parameter clientId was null or undefined when calling clientsClientIdGet.')
			}
			const localVarPath = `/clients/{clientId}`
				.replace(`{${'clientId'}}`, encodeURIComponent(String(clientId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить всех клиентов
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsGet(options: any = {}): FetchArgs {
			const localVarPath = `/clients`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Создать клиента
		 * @param {ClientDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsPost(body: ClientDto, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling clientsPost.')
			}
			const localVarPath = `/clients`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ClientDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Обновить основную информацию по клиенту
		 * @param {ClientDto} body
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdClientUpdatingPost(body: ClientDto, clientId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsClientIdClientUpdatingPost(body, clientId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Удалить клиента
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdDelete(clientId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsClientIdDelete(clientId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить клиента по идентификатору
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdGet(clientId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClientDto> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsClientIdGet(clientId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить всех клиентов
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectDto>> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsGet(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Создать клиента
		 * @param {ClientDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsPost(body: ClientDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Обновить основную информацию по клиенту
		 * @param {ClientDto} body
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdClientUpdatingPost(body: ClientDto, clientId: number, options?: any) {
			return ClientApiFp(configuration).clientsClientIdClientUpdatingPost(body, clientId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Удалить клиента
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdDelete(clientId: number, options?: any) {
			return ClientApiFp(configuration).clientsClientIdDelete(clientId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить клиента по идентификатору
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdGet(clientId: number, options?: any) {
			return ClientApiFp(configuration).clientsClientIdGet(clientId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить всех клиентов
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsGet(options?: any) {
			return ClientApiFp(configuration).clientsGet(options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Создать клиента
		 * @param {ClientDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsPost(body: ClientDto, options?: any) {
			return ClientApiFp(configuration).clientsPost(body, options)(fetch, basePath)
		},
	}
}

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
	/**
	 *
	 * @summary Обновить основную информацию по клиенту
	 * @param {ClientDto} body
	 * @param {number} clientId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsClientIdClientUpdatingPost(body: ClientDto, clientId: number, options?: any) {
		return ClientApiFp(this.configuration).clientsClientIdClientUpdatingPost(body, clientId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Удалить клиента
	 * @param {number} clientId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsClientIdDelete(clientId: number, options?: any) {
		return ClientApiFp(this.configuration).clientsClientIdDelete(clientId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить клиента по идентификатору
	 * @param {number} clientId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsClientIdGet(clientId: number, options?: any) {
		return ClientApiFp(this.configuration).clientsClientIdGet(clientId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить всех клиентов
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsGet(options?: any) {
		return ClientApiFp(this.configuration).clientsGet(options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Создать клиента
	 * @param {ClientDto} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsPost(body: ClientDto, options?: any) {
		return ClientApiFp(this.configuration).clientsPost(body, options)(this.fetch, this.basePath)
	}

}

/**
 * CostApi - fetch parameter creator
 * @export
 */
export const CostApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить издержку по идентификатору
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdGet(costId: number, options: any = {}): FetchArgs {
			// verify required parameter 'costId' is not null or undefined
			if (costId === null || costId === undefined) {
				throw new RequiredError('costId', 'Required parameter costId was null or undefined when calling costsCostIdGet.')
			}
			const localVarPath = `/costs/{costId}`
				.replace(`{${'costId'}}`, encodeURIComponent(String(costId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить все издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsGet(options: any = {}): FetchArgs {
			const localVarPath = `/costs`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Создать издержку
		 * @param {Cost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsPost(body: Cost, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling costsPost.')
			}
			const localVarPath = `/costs`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'Cost' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * CostApi - functional programming interface
 * @export
 */
export const CostApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить издержку по идентификатору
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdGet(costId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cost> {
			const localVarFetchArgs = CostApiFetchParamCreator(configuration).costsCostIdGet(costId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить все издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Cost>> {
			const localVarFetchArgs = CostApiFetchParamCreator(configuration).costsGet(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Создать издержку
		 * @param {Cost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsPost(body: Cost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = CostApiFetchParamCreator(configuration).costsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * CostApi - factory interface
 * @export
 */
export const CostApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить издержку по идентификатору
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdGet(costId: number, options?: any) {
			return CostApiFp(configuration).costsCostIdGet(costId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить все издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsGet(options?: any) {
			return CostApiFp(configuration).costsGet(options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Создать издержку
		 * @param {Cost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsPost(body: Cost, options?: any) {
			return CostApiFp(configuration).costsPost(body, options)(fetch, basePath)
		},
	}
}

/**
 * CostApi - object-oriented interface
 * @export
 * @class CostApi
 * @extends {BaseAPI}
 */
export class CostApi extends BaseAPI {
	/**
	 *
	 * @summary Получить издержку по идентификатору
	 * @param {number} costId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CostApi
	 */
	public costsCostIdGet(costId: number, options?: any) {
		return CostApiFp(this.configuration).costsCostIdGet(costId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить все издержки
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CostApi
	 */
	public costsGet(options?: any) {
		return CostApiFp(this.configuration).costsGet(options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Создать издержку
	 * @param {Cost} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CostApi
	 */
	public costsPost(body: Cost, options?: any) {
		return CostApiFp(this.configuration).costsPost(body, options)(this.fetch, this.basePath)
	}

}

/**
 * ProjectApi - fetch parameter creator
 * @export
 */
export const ProjectApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить все проекты
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsGet(options: any = {}): FetchArgs {
			const localVarPath = `/projects`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Создать проект
		 * @param {ProjectDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsPost(body: ProjectDto, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectsPost.')
			}
			const localVarPath = `/projects`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ProjectDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Удалить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdDelete(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdDelete.')
			}
			const localVarPath = `/projects/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'DELETE'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить проект по идентификатору
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdGet(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdGet.')
			}
			const localVarPath = `/projects/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Обновить основную информацию по проекту
		 * @param {ProjectDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdProjectUpdatingPost(body: ProjectDto, projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectsProjectIdProjectUpdatingPost.')
			}
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdProjectUpdatingPost.')
			}
			const localVarPath = `/projects/{projectId}/project-updating`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ProjectDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить все проекты
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectDto>> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsGet(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Создать проект
		 * @param {ProjectDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsPost(body: ProjectDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Удалить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdDelete(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdDelete(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить проект по идентификатору
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdGet(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectDto> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdGet(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Обновить основную информацию по проекту
		 * @param {ProjectDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdProjectUpdatingPost(body: ProjectDto, projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdProjectUpdatingPost(body, projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить все проекты
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsGet(options?: any) {
			return ProjectApiFp(configuration).projectsGet(options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Создать проект
		 * @param {ProjectDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsPost(body: ProjectDto, options?: any) {
			return ProjectApiFp(configuration).projectsPost(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Удалить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdDelete(projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdDelete(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить проект по идентификатору
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdGet(projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdGet(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Обновить основную информацию по проекту
		 * @param {ProjectDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdProjectUpdatingPost(body: ProjectDto, projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdProjectUpdatingPost(body, projectId, options)(fetch, basePath)
		},
	}
}

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
	/**
	 *
	 * @summary Получить все проекты
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsGet(options?: any) {
		return ProjectApiFp(this.configuration).projectsGet(options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Создать проект
	 * @param {ProjectDto} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsPost(body: ProjectDto, options?: any) {
		return ProjectApiFp(this.configuration).projectsPost(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Удалить проект
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdDelete(projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdDelete(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить проект по идентификатору
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdGet(projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdGet(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Обновить основную информацию по проекту
	 * @param {ProjectDto} body
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdProjectUpdatingPost(body: ProjectDto, projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdProjectUpdatingPost(body, projectId, options)(this.fetch, this.basePath)
	}

}

/**
 * ProjectBudgetApi - fetch parameter creator
 * @export
 */
export const ProjectBudgetApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить бюджет по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdGet(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectBudgetsProjectIdGet.')
			}
			const localVarPath = `/project-budgets/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Обновить бюджет проекта
		 * @param {ProjectBudgetDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdProjectBudgetUpdatingPost(body: ProjectBudgetDto, projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectBudgetsProjectIdProjectBudgetUpdatingPost.')
			}
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectBudgetsProjectIdProjectBudgetUpdatingPost.')
			}
			const localVarPath = `/project-budgets/{projectId}/project-budget-updating`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ProjectBudgetDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ProjectBudgetApi - functional programming interface
 * @export
 */
export const ProjectBudgetApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить бюджет по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdGet(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectBudgetDto> {
			const localVarFetchArgs = ProjectBudgetApiFetchParamCreator(configuration).projectBudgetsProjectIdGet(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Обновить бюджет проекта
		 * @param {ProjectBudgetDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdProjectBudgetUpdatingPost(body: ProjectBudgetDto, projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectBudgetDto> {
			const localVarFetchArgs = ProjectBudgetApiFetchParamCreator(configuration).projectBudgetsProjectIdProjectBudgetUpdatingPost(body, projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * ProjectBudgetApi - factory interface
 * @export
 */
export const ProjectBudgetApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить бюджет по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdGet(projectId: number, options?: any) {
			return ProjectBudgetApiFp(configuration).projectBudgetsProjectIdGet(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Обновить бюджет проекта
		 * @param {ProjectBudgetDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdProjectBudgetUpdatingPost(body: ProjectBudgetDto, projectId: number, options?: any) {
			return ProjectBudgetApiFp(configuration).projectBudgetsProjectIdProjectBudgetUpdatingPost(body, projectId, options)(fetch, basePath)
		},
	}
}

/**
 * ProjectBudgetApi - object-oriented interface
 * @export
 * @class ProjectBudgetApi
 * @extends {BaseAPI}
 */
export class ProjectBudgetApi extends BaseAPI {
	/**
	 *
	 * @summary Получить бюджет по проекту
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectBudgetApi
	 */
	public projectBudgetsProjectIdGet(projectId: number, options?: any) {
		return ProjectBudgetApiFp(this.configuration).projectBudgetsProjectIdGet(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Обновить бюджет проекта
	 * @param {ProjectBudgetDto} body
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectBudgetApi
	 */
	public projectBudgetsProjectIdProjectBudgetUpdatingPost(body: ProjectBudgetDto, projectId: number, options?: any) {
		return ProjectBudgetApiFp(this.configuration).projectBudgetsProjectIdProjectBudgetUpdatingPost(body, projectId, options)(this.fetch, this.basePath)
	}

}
